# CS-250-Final-Project
Sprint Review and Retrospective from CS 250: Software Development Lifecycle. Includes Agile and Scrum practices, plus reflections on user needs, Agile development, and teamwork as part of my Computer Science portfolio.

1. How do I figure out what users need and turn those needs into a working program?**

Understanding user needs starts with truly listening — asking questions, observing behavior, and picking up on not just what people *say* they want, but what they actually *need* to solve their problems. Once I have a good grasp of their goals and frustrations, I can start mapping those into features and design choices that make sense. It's less about building what sounds "cool" and more about creating something *useful and intuitive* that fits into their real lives.

2. How does creating “user stories” make it easier to understand and meet user needs?**

User stories help by keeping the focus on *the human side* of the project. When I write a user story — like "As a new player, I want an easy tutorial so I can start playing without feeling overwhelmed" — it reminds me *why* I'm building something, not just *what* I'm building. It helps break down big ideas into small, meaningful tasks that directly tie back to a real person’s experience.

3. How do I personally approach developing programs?**

When I sit down to develop something, I start by getting clear on the problem I’m solving. I like to plan just enough to feel organized, but not so much that it freezes creativity. I build in small steps, test a lot, and stay flexible when things inevitably change. I’ve learned it’s better to get something simple working quickly and improve it over time than to chase perfection right out of the gate.

4. What Agile processes do I want to use in my future development work?**

Moving forward, I want to lean heavily into Agile practices like doing stand-ups to stay aligned, sprint planning to keep projects manageable, and retrospectives to constantly learn from what’s working (and what isn’t). I really like the idea of delivering small, working pieces often instead of waiting months to have something to show. It keeps momentum going and makes collaboration smoother.

5. What does being a good team member in software development actually mean to me?**

To me, being a good teammate means *communicating openly*, *being dependable*, and *staying humble*. It’s about sharing ideas, giving and receiving feedback kindly, and never acting like any one person has all the answers. A great team member lifts up the whole group, not just themselves. And when challenges pop up (because they always do), they’re ready to pitch in and solve problems together instead of pointing fingers.
